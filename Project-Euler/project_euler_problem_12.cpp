/**
    @file project_euler_problem_12.cpp

    @author Terence Henriod

    Project Euler Problem 12

    @brief Solves the following problem for the general case of any number of
           divisors for a triangular number:

  "The sequence of triangle numbers is generated by adding the natural numbers.
   So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
   ten terms would be:

   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

   Let us list the factors of the first seven triangle numbers:

    1: 1
    3: 1,3
    6: 1,2,3,6
   10: 1,2,5,10
   15: 1,3,5,15
   21: 1,3,7,21
   28: 1,2,4,7,14,28
   We can see that 28 is the first triangle number to have over five divisors.

   What is the value of the first triangle number to have over five hundred
   divisors?"

    @version Original Code 1.00 (1/3/2014) - T. Henriod
*/

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   HEADER FILES / NAMESPACES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#include <cassert>
#include <cmath>
#include <cstdio>
#include <iostream>
#include <fstream>
#include "z_primes.h"
using namespace std;


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   GLOBAL CONSTANTS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
const int kFirstPrime = 2;
const long long kAbundantTriangles[] =
    {1, 3, 6, 28, 36, 120, 300, 528, 630, 2016, 3240, 5460, 25200, 73920,
     157080, 437580, 749700, 1385280, 1493856, 2031120, 2162160, 17907120,
     76576500, 103672800, 236215980, 842161320, 3090906000, 4819214400,
     7589181600, 7966312200, 13674528000, 20366564400, 49172323200,
     78091322400, 102774672000, 557736444720, 666365279580, 876785263200,
     1787835551040, 2427046221600, 3798207594720, 24287658595200,
     26571463158240};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   FUNCTION PROTOTYPES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
FunctionName

A short description

@param

@return

@pre
-# 

@post
-# 

@detail @bAlgorithm
-# 

@exception

@code
@endcode
*/
long long findTriangularNumberWithNFactors(
    const long long requisite_factors);
long long getNthTriangleNumber(const long long n);
unsigned int countDivisors(const long long triangular_number);


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   MAIN FUNCTION
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
int main() {
  // variables
  long long requisite_factors = 500;
  long long triangular_number = 0;

  // get the least number of divisors the triangular number should have
  printf("Enter the requisite number of factors the triangular number needs: ");
  scanf("%u", &requisite_factors);

  // get the triangular number
  triangular_number = findTriangularNumberWithNFactors(requisite_factors);

  // report the result to the user
  printf("\nThe triangular number with %u or more factors is: ",
         requisite_factors);
cout << triangular_number << endl;

  // return 0 on successful completion
  return 0;
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   FUNCTION IMPLEMENTATIONS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
long long findTriangularNumberWithNFactors(
    const long long requisite_factors) {
  // variables
  long long solution = 3; // the n=2 triangle number
  unsigned int nth = 2;
  unsigned int divisor_count = 2;

  // check triangular numbers until a number with enough divisors is found
  while (divisor_count < requisite_factors) {
    // move on to the next even "even nth" triangular number
    nth++;

    // case: nth is even
    if ((nth % 2) == 0) {
      // count the factors of the number by splitting terms of the formula
      divisor_count = (countDivisors(nth / 2) * countDivisors(nth + 1));
    }
    // case: nth is odd
    else {
      // count the factors of the number by splitting terms of the formula
      divisor_count = (countDivisors((nth + 1) / 2) * countDivisors(nth));
    }
  }

  // compute the solution
  solution = getNthTriangleNumber(nth);

  // return the triangle number
  return solution;
}

long long getNthTriangleNumber(const long long n) {
  // compute the triangular number with its formula
  return ((n * (n + 1)) / 2);
}

unsigned int countDivisors(const long long number) {
  // variables
  long long divisor_count = 1;
  long long temp = number;
  long long prime_multiplicity = 0;
  unsigned int prime_ndx = 0;

  // look for all primes that are factors
  while (temp > 1) {
    // reset the multiplicity counter
    prime_multiplicity = 0;

    // case: the current prime is a divisor
    //       add counts of multiplicities until no more of that prime
    //       factor can be divided out
    while ((temp % kPrimes[prime_ndx]) == 0) {

        // count the multiplicity
        prime_multiplicity++;

        // divide the factor out
        temp /= kPrimes[prime_ndx];
    }

    // count the current prime as a divisor (and its multiplicities)
    divisor_count *= (prime_multiplicity + 1);

    // move on to the next prime number
    prime_ndx++;

    // case: we have exhausted our primes list
    if (prime_ndx >= kNumPrimes) {
      // throw an exception
      throw 666;  // TODO: throw something better
    }
  }

  // return the number of divisors
  return divisor_count;
}
